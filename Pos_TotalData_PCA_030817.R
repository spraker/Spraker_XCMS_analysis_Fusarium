##2017-03-08 - JoeSpraker 
## email: jspraker@email.arizona.edu
## PCA of F.fujikuroi metabolites using XCMS with support from Camera
##This analysis was run on all MS1 data generated by Phil Weimann 02/17 and 08/16
## All data groups must be loaded into separate directories as indicated in: Smith CA, Want EJ, Maille GO, Abagyan R, Siuzdak G. 2006. XCMS: Processing mass spectrometry data for metabolite profiling using nonlinear peak alignment, matching, and identification. Anal Chem 78:779â€“787.
##For example these data were split into six directories labeled: "GMI_high", "GMI_low", "media_high", "media_low", "rmy_high" and "rmy_low"

#Load dependencies
source("http://bioconductor.org/biocLite.R")
biocLite("xcms", dep=T)
biocLite("CAMERA")
library(xcms)
library(multtest)
library(CAMERA)
library(ggplot2)

# Set your working directory containing all mzXML formatted files by changing "path/to/directory/" below, to appropriate directory
setwd("path/to/directory/")
#optional: reduce print output for checking datasets to first 50 (saves space)
options(max.print=50)
#Peak identification and filtration - one row per dataset output (m/z:number of peaks)
## Add argument nSlaves=x to specify number of cores to be used.
xset<-xcmsSet(method="centWave", ppm=2.5, peakwidth=c(5,20), prefilter=c(3,50000), nSlaves=4)
#Perform retention time correction across samples
xset1 <- retcor(xset, method="obiwarp", plottype = c("deviation"))
#Match peaks across samples
xset2 <- group(xset1, bw = 5, minfrac = 0.5, mzwid = 0.015)
#Fill in missing peaks and calculate statistics
xset3 <- fillPeaks(xset2) 
#Generate feature tables and EICs
##change class labels based on pairwise comparison
dr <- diffreport(xset3, filebase ="Total_dataset", eicmax=100)# metlin=0.15)
#Stats/analysis of results with annotation of predicted adducts and isotopes in dataset
xset4<-annotateDiffreport(xset3, pval=0.05, pval_th=0.10, nSlaves=4, ppm=10, polarity="positive", calcIso = TRUE)
#Print results to .csv
write.csv(xset4, file="annotdiffreport.csv")
write.csv(dr, file = "dr_ANOVA")

##Read in from file to convert column class to numeric
dr<-read.csv("dr_ANOVA")

##MULTIVARIATE ANALYSES
##Calculate Relative Standard Deviations (RSD) for all sample types
###Need to change names and column numbers according to dataset
#select data to be used
GMIHrows<-dr[,20:23]
mediaHrows<-dr[,24:27]
rmyHrows<-dr[,28:31]
GMILrows<-dr[,32:35]
mediaLrows<-dr[,36:39]
rmyLrows<-dr[,40:43]
#calculate SD and average for each treatment type
#StdDev
SDGMIH<-apply(GMIHrows, 1 , sd)
SDmediaH<-apply(mediaHrows, 1 , sd)
SDrmyH<-apply(rmyHrows, 1 , sd)
SDGMIL<-apply(GMILrows, 1 , sd)
SDmediaL<-apply(mediaLrows, 1 , sd)
SDrmyL<-apply(rmyLrows, 1 , sd)
#Mean
GMIHmean<-rowMeans(GMIHrows)
mediaHmean<-rowMeans(mediaHrows)
rmyHmean<-rowMeans(rmyHrows)
GMILmean<-rowMeans(GMILrows)
mediaLmean<-rowMeans(mediaLrows)
rmyLmean<-rowMeans(rmyLrows)
#calculate RSD (SD/Mean) and minimum RSD, put in data frame
dr$RSD_GMI_H<-SDGMIH/GMIHmean
dr$RSD_media_H<-SDmediaH/mediaHmean
dr$RSD_rmy_H<-SDrmyH/rmyHmean
dr$RSD_GMI_L<-SDGMIL/GMILmean
dr$RSD_media_L<-SDmediaL/mediaLmean
dr$RSD_rmy_L<-SDrmyL/rmyLmean
dr$minRSD<-apply(dr[,44:49],1,min)
minRSD<-apply(dr[,44:49],1,min)
#Trim by lowest RSD and anova
RtbTrimmed<-dr[minRSD<0.3,]
RtbTrimmed<-subset(RtbTrimmed, anova <= 0.05,)
#Remove "NA" rows from dataframe
RtbTrimmed<-RtbTrimmed[complete.cases(RtbTrimmed),]
#Write to csv
write.csv(RtbTrimmed, "RSDTrimmedOutput.csv")

###Prompt
#select data columns based on attributes output (here I select 12 columns containing 4 reps of each of 6 treatments)
samptab<-RtbTrimmed[,20:43]
#transpose to rows
samptabT<-t(samptab)
#create label list
sampLabels<-c("GMI HighN", "GMI HighN", "GMI HighN", "GMI HighN", "gMI LowN", "gMI LowN", "gMI LowN", "gMI LowN", "Media HighN", "Media HighN", "Media HighN", "Media HighN", "media LowN", "media LowN", "media LowN", "media LowN", "RmyA HighN", "RmyA HighN", "RmyA HighN", "RmyA HighN", "rmyA LowN", "rmyA LowN", "rmyA LowN", "rmyA LowN" )
#principal component analyses putting results in object "pca"
pca<-prcomp(samptabT, center=TRUE, scale=TRUE)
#plot PC 1 and 2 (example: can be changed for other pc vectors)
plot(pca$x[,1], pca$x[,2], pch=sampLabels)
#plot loadings (rotations) to csv and combine with trimmed data to determine which peaks contributed most to differences between samples (sort by ABS(PCAn))
pcaX<-as.data.frame(pca$rotation[,1:3])
pcaX<-abs(pcaX)
total<-merge(RtbTrimmed, pcaX, by=0)
write.csv(total, "DataMergePCA.csv")
##open MergePCA in excel and sort by PC(n) (value highest to lowest) to determine which compounds contribute most to each principal component (n)
##Plot with qplot
pdf("PCAplot.pdf", width=7, height=4)
qplot(pca$x[,1], pca$x[,2], pch=sampLabels, xlab="PC1", ylab="PC2", color=sampLabels, main="All Samples")
dev.off()
## Calculate eigenvalues for each principal component
pc <-(prcomp(samptabT, center=TRUE, scale=TRUE))
evcol <- pc$sdev^2
evsum <- sum(ev)
eigen<-(evcol/evsum)*100
write.csv(eigen, "Eigen.csv")